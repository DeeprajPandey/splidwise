<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>API Reference | Splidwise</title>
</head>
<body>
  <script src="https://api.apiary.io/seeds/embed.js"></script>
  <script>
    var embed = new Apiary.Embed({
      apiBlueprint: "FORMAT: 1A\nHOST: https://fathomless-fortress-82121.herokuapp.com\n# SpliDwise\n\nSplidwise is an API that talks to hyperledger fabric to manage shared expenses.\n\nA few nomenclature clarifications:\n- `Transaction`: A hyperledger txn that goes on the blockchain. A txn records any modification to the world state.\n- `Payment`: Representation of real world payments (bill-splits) between two registered users. Users can add these payments on the app.\n- `Payment Link`: When any user (creditor) makes a payment for another user (debtor), a link between them is created and has a specific representation on the world state. Subsequent similar payments will be added to this link.\n\nNote: all parameters in api calls (`user` emails) denote the registered account that is logged in on the app and is sending that request.\n\n# Group General Resources\n\nGeneral resources that would be called by the app for global changes.\n\n## List All Assets in World State [/queryAll]\n\n### /queryAll [GET]\n\nNote: this is a dummy resource to give you an idea about the world state structure. This actually does not exist on splidwise backend.\n\nList of all the key-value pairs in the world state. Assets are either pairs of keys: tuples of (creditor, debtor) and values: arrays of user payments or keys: strings which denote the user IDs of registered users and values: objects with personal info. User keys also store the password hash which is obviously never returned from any API calls.\n\nLimit to 20 assets.\n\n+ Response 200 (application/json)\n    {\n        \"data\": {\n            \"(creditor_uid3,debtor_uid1,1)\": {\n                \"pmtid\": 1,\n                \"amount\": 20,\n                \"approved\": false,\n                \"description\": \"Paid for dinner\",\n                \"timestamp\": \"1586471276\"\n            },\n            \"(creditor_uid3,debtor_uid1,2)\": {\n                \"pmtid\": 2,\n                \"amount\": 30,\n                \"approved\": true,\n                \"description\": \"THC lunch\",\n                \"timestamp\": \"1586554076\"\n            },\n            \"(creditor_uid117,debtor_uid60,1)\": {\n                \"pmtid\": 1,\n                ...\n            },\n            \"userid3\": {\n                \"name\": \"Mahavir Jhawar\",\n                \"p_hash\": \"\",\n                \"lent_money_to\": [[\"debtor_uid1\",2], [\"debtor_uid54\",1], [\"debtor_uid7\",5]],\n                \"owes_money_to\": [\"creditor_uid12\", \"creditor_uid30\"]\n            }\n        },\n        \"message\": \"Entire world state.\"\n    }\n\n## Create New User [/registerUser]\n\n### /registerUser [POST]\n\nUse this to create a new user for the app. It takes a JSON object with email and personal information in the form another object.\n\n- username (string) - The email ID.\n- info (mixed object) - Collection of personal details.\n\n+ Request (application/json)\n    {\n        \"username\": \"user1@protonmail.com\",\n        \"info\": {\n            \"name\": \"Fettered Darwin\",\n            \"p_hash\": \"random_string\"\n        }\n    }\n\n+ Response 201 (application/json)\n    {\n        \"data\": {\n            \"username\": \"user1@protonmail.com\",\n            \"info\": {\n                \"name\": \"Fettered Darwin\",\n                \"lent_money_to\": [],\n                \"owes_money_to\": []\n            }\n        },\n        \"message\": \"User created successfully.\"\n    }\n\n## Get User Data [/{user}/getUserData]\n\n+ Parameters\n    + user: user3@protonmail.com (string) - Globally unique identifier (email) for registered user. Will be checked both in wallet and world state.\n\n### /getUserData [POST]\n\nGet the value in world state corresponding to a registered user. The response will also have a found field which will be set to false if the user is not found. Make a call to this first and assert that user does not exist before calling `/registerUser`. Request object has only one param:\n\n- passw_hash (string) - Hash of the password the user used to log in.\n\n+ Request (application/json)\n    {\n        \"passw_hash\": \"feboywfiw\"\n    }\n\n+ Response 200 (application/json)\n    {\n        \"data\": {\n            \"name\": \"Mahavir Jhawar\",\n            \"lent_money_to\": [[\"debtor_uid1\",2], [\"debtor_uid54\",1], [\"debtor_uid7\",5]],\n            \"owes_money_to\": [\"creditor_uid12\", \"creditor_uid30\"]\n        },\n        \"message\": \"User data returned successfully [or] Invalid username or password.\"\n    }\n\n# Group User Specific Resources\n\nAPI calls expected to be made from registered user when they use the app. Registered usernames are almost always a part of the request object.\n\n## Credit/Debt Summary [/{user}/getAmountOwed]\n\n+ Parameters\n    + user: user3@protonmail.com (string) - Globally unique identifier (email) for registered user. Will be checked both in wallet and world state.\n\n### /{user}/getAmountOwed [POST]\n\nUse this to get the credit-debt situation between two registered users. It takes a JSON object with creditor and debtor usernames.\n\nThis will usually be used by the creditor logged into the app and requesting to see a summary of money lent/owed to debtor. Receiving amount could be negative, effectively meaning the roles are reversed (handled on the frontend).\n\n- creditor (string) - Email ID of the user lending money. This will be the same as `user` param.\n- debtor (string) - Email ID of the user who is in debt.\n\n+ Request (application/json)\n{\n    \"creditor\": \"user1@protonmail.com\",\n    \"debtor\": \"olduser43@protonmail.com\"\n}\n\n+ Response 201 (application/json)\n    {\n        \"data\": {\n            \"creditor\": \"user1@protonmail.com\",\n            \"debtor\": \"olduser43@protonmail.com\",\n            \"amount_owed\": -260,\n            \"unapproved_amount\": 15\n        },\n        \"message\": \"Credit [or] Debt calculated successfully.\"\n    }\n\n+ Response 404 (application/json)\n    {\n        \"data\": {},\n        \"message\": \"Creditor/debtor user not found.\"\n    }\n\n## Make Payment Between Users [/{user}/makePayment]\n\n+ Parameters\n    + user: user3@protonmail.com (string) - Globally unique identifier (email) for registered user. Will be checked both in wallet and world state.\n\n### /{user}/makePayment [POST]\n\nThe creditor will use this to make a payment on behalf of the debtor. Both have to be registered users else it returns 404 with a message saying so. If a payment link does not exist then the chaincode will create a new link else it will add this payment to the array in the existing link.\n\nExpected inputs:\n- creditor (string) - Email ID of the user lending money. This will be the same as `user` param.\n- debtor (string) - Email ID of the user for whom creditor is paying.\n- amount (int) - The money being paid.\n- description (string) - A helpful description for the payment.\n- timestamp (unix time) - Time when the payment was added by creditor.\n\n+ Request (application/json)\n{\n    \"creditor\": \"user3@protonmail.com\",\n    \"debtor\": \"olduser@protonmail.com\",\n    \"amount\": 30,\n    \"description\": \"THC Lunch\",\n    \"timestamp\": \"1586554076\"\n}\n\n+ Response 201 (application/json)\n    {\n        \"data\": {\n            {\n                \"pmtid\": 2,\n                \"amount\": 30,\n                \"approved\": false,\n                \"description\": \"THC lunch\",\n                \"timestamp\": \"1586554076\"\n            }\n        },\n        \"message\": \"Payment added to link.\"\n    }\n\n+ Response 404 (application/json)\n    {\n        \"data\": {},\n        \"message\": \"Creditor/debtor user not found.\"\n    }\n\n## Get All Unapproved Payments for User [/{user}/getUnapprovedPayments]\n\n+ Parameters\n    + user: user3@protonmail.com (string) - Globally unique identifier (email) for registered user. Will be checked both in wallet and world state.\n\n### /{user}/getUnapprovedPayments [POST]\n\nThe debtor will use this to get all the payments that are pending their approval. Empty response if there are no payments pending approval.\n\nExpected inputs:\n- debtor (string) - Email ID of the user for whom creditor is paying. This has to be the same as `user` param.\n\n+ Request (application/json)\n{\n    \"debtor\": \"user3@protonmail.com\"\n}\n\n+ Response 201 (application/json)\n    {\n        \"data\": {\n            \"debtor\": \"olduser@protonmail.com\",\n            \"all_unapproved_pmts\": [\n                {\n                    \"creditor\": \"user1@gmail.com\",\n                    \"pmtid\": 2,\n                    \"amount\": 30,\n                    \"approved\": false,\n                    \"description\": \"THC lunch\",\n                    \"timestamp\": \"1586554076\"\n                },\n                {\n                    \"creditor\": \"user8@gmail.com\",\n                    \"pmtid\": 7,\n                    ...\n                }\n            ]\n        },\n        \"message\": \"Unapproved payments found [or] No payments pending approval.\"\n    }\n\n+ Response 404 (application/json)\n    {\n        \"data\": {},\n        \"message\": \"Debtor user not found.\"\n    }\n\n## Approve a Single Payment Object [/{user}/approvePayment]\n\n+ Parameters\n    + user: user3@protonmail.com (string) - Globally unique identifier (email) for registered user. Will be checked both in wallet and world state.\n\n### /{user}/approvePayment [POST]\n\nThe debtor will use this (after /getUnapprovedPayments with a particular creditor) to approve a payment that creditor maid on their behalf.\n\nNote: this approves only one payment object whereas `/getUnapprovedPayments` returns an array of payment objects.\n\nExpected inputs:\n- debtor (string) - Email ID of the user for whom creditor is paying.  This will be the same as `user` param.\n- creditor (string) - Email ID of the user lending money.\n- payment_obj (mixed object) - The complete payment object where `approved` is set to false (this will be set to true by chaincode).\n\n+ Request (application/json)\n{\n    \"debtor\": \"user3@protonmail.com\",\n    \"creditor\": \"user1@gmail.com\",\n    \"payment_obj\": {\n        \"pmtid\": 2,\n        \"amount\": 30,\n        \"approved\": false,\n        \"description\": \"THC lunch\",\n        \"timestamp\": \"1586554076\"\n    }\n}\n\n+ Response 201 (application/json)\n    {\n        \"data\": {\n            \"debtor\": \"user3@protonmail.com\",\n            \"creditor\": \"user1@gmail.com\",\n            \"payment_obj\": {\n                \"pmtid\": 2,\n                \"amount\": 30,\n                \"approved\": true,\n                \"description\": \"THC lunch\",\n                \"timestamp\": \"1586554076\"\n            }\n        },\n        \"message\": \"Payment approved.\"\n    }\n\n+ Response 404 (application/json)\n    {\n        \"data\": {},\n        \"message\": \"Payment data not found.\"\n    }"
    });

    if (false) {
        var changed = null;
        var xhrChanged = new XMLHttpRequest();
        var xhrData = new XMLHttpRequest();
        setInterval(function() {
            xhrChanged.open('GET', window.location.href + "/changed", true);
            xhrChanged.send();

            xhrChanged.onreadystatechange = function() {
                if (xhrChanged.readyState === 4 && xhrChanged.status === 200) {
                    if (!changed) {
                        changed = xhrChanged.responseText;
                    }
                    if (changed != xhrChanged.responseText) {
                        changed = xhrChanged.responseText;
                        xhrData.open('GET', window.location.href + "/source", true);
                        xhrData.send();

                        xhrData.onreadystatechange = function() {
                            if (xhrData.readyState === 4 && xhrData.status === 200) {
                                window[embed.adaptee.id].contentWindow.postMessage({"origin": "Apiary.Embed", "eventType": "anonymousPreview", "data": {"code": xhrData.responseText}}, '*');
                            }
                        }
                    }
                }
            }
        }, 1000);
    }
  </script>
</body>
</html>
